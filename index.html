<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Function ThreeJS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body style="margin:0;">

		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./js/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { NURBSCurve } from './js/NURBSCurve.js';
			import { NURBSSurface } from './js/NURBSSurface.js';
			import { ParametricGeometry } from './js/ParametricGeometry.js';

			let container, stats;

			let camera, scene, renderer;
			let group;

			let targetRotationX = 0;
			let targetRotationY = 0;

			let targetRotationXOnPointerDown = 0;
			let targetRotationYOnPointerDown = 0;

			let pointerX = 0;
			let pointerY = 0;
			let pointerXOnPointerDown = 0;
			let pointerYOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function createlinesym(x,y,z,color,group){
				// Pour cr√©er des axes

				let materialline = new THREE.LineBasicMaterial({
					color: color
				});

				let points = [];
				points.push( new THREE.Vector3( -x, -y, -z ) );
				points.push( new THREE.Vector3( x, y, z ) );

				let geometry_line = new THREE.BufferGeometry().setFromPoints( points );
				let line = new THREE.Line( geometry_line, materialline );
				group.add( line );
			}
			
			function create_function(xmin,xmax,ymin,ymax,zmin,zmax,presx,presy,f,group,color){
				let nsControlPoints = []
				let knots1 = [0];
				let knots2 = [0];
				let noi = 0
				let noy = 0
				for (let i=xmin; i<=xmax; i+=presx){
					let intermediate = []
					for (let j=ymin; j<=ymax; j+=presy){
						let calcul
						let index
						
						let last = ""
						if (intermediate[intermediate.length-1]){
							last = intermediate[intermediate.length-1]["y"]
						}

						if ( f(i,j) > zmax || f(i,j) < zmin ) {
							calcul = NaN
							index = j
						}
						else {
							calcul = f(i,j)
							index = j
						}

						intermediate.push ( new THREE.Vector4(i, calcul , index,1) )
						
						noy +=1
					}
					noi +=1
					nsControlPoints.push(intermediate)
				}

				noy=noy/noi

				for ( let i = 0,j=noi; i < j; i+=1 ) {
					let knot = (i + 1) / j;
					knots1.push(THREE.Math.clamp(knot, 0, 1))
				}

				for ( let i = 0,j=noy; i < j; i+=1 ) {
					let knot = (i + 1) / j;
					knots2.push(THREE.Math.clamp(knot, 0, 1))
				}

				const nurbsSurface = new NURBSSurface( 0, 0, knots1, knots2, nsControlPoints );

				function getSurfacePoint( u, v, target ) { return nurbsSurface.getPoint( u, v, target ); }

				const geometry = new ParametricGeometry( getSurfacePoint, noi, noy );

				const material = new THREE.MeshBasicMaterial( {
					color: color,
					wireframe: true,
				})

				const object = new THREE.Mesh( geometry, material );
				object.position.set( 0, 0, 0 );
				group.add( object );
			}


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 0, 200);
				camera.rotation.set( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xF0f0f0 );

				scene.add( new THREE.AmbientLight( 0xffffff ) );

				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0, 0, 0 );
				scene.add( light );

				group = new THREE.Group();
				group.position.y = 0;
				group.position.y = 0;

				scene.add( group );

				createlinesym(1000,0,0,0xFF0000,group); //x
				createlinesym(0,0,1000,0x00FF00,group); //y
				createlinesym(0,1000,0,0x0000FF,group); //z		
				
				const query = window.location.search
				const params = Object.fromEntries(new URLSearchParams(query))

				let zoom = parseFloat(params.zoom)
				let xmin = parseFloat(params.xmin)
				let xmax = parseFloat(params.xmax)
				let ymin = parseFloat(params.ymin)
				let ymax = parseFloat(params.ymax)
				let zmin = parseFloat(params.zmin)
				let zmax = parseFloat(params.zmax)
				let presx = (1/zoom);
				let presy = (1/zoom);

				let functions = JSON.parse(params.functions)

				for (let fun of functions){
					function f(x,y){
						return eval(fun);
					}
	
					create_function(xmin,xmax,ymin,ymax,zmin,zmax,presx,presy,f,group,0x7777FF)
				}


				group.scale.multiplyScalar( zoom );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				window.addEventListener( 'resize', onWindowResize );
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onPointerDown( event ) {
				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationXOnPointerDown = targetRotationX;

				pointerYOnPointerDown = event.clientY - windowHalfY;
				targetRotationYOnPointerDown = targetRotationY;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );
			}

			function onPointerMove( event ) {
				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;
				pointerY = event.clientY - windowHalfY;

				targetRotationX = targetRotationXOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;
				targetRotationY = targetRotationYOnPointerDown + ( pointerY - pointerYOnPointerDown ) * 0.02;
			}

			function onPointerUp() {
				if ( event.isPrimary === false ) return;
				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );
			}

			function animate() {
				requestAnimationFrame( animate )
				render();
			}

			function render() {
				group.rotation.y += ( targetRotationX - group.rotation.y ) * 0.05;
				group.rotation.x += ( targetRotationY - group.rotation.x ) * 0.05;
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
